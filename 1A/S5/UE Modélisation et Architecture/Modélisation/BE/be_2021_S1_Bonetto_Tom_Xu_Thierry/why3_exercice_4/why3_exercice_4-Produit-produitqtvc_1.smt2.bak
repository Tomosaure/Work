;; produced by cvc4_16.drv ;;
(set-logic AUFBVFPDTNIRA)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun string () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

;; bool_inversion
  (assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

(declare-fun tuple01 () ty)

(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
  (assert (forall ((u tuple0)) (= u Tuple0)))

;; CompatOrderMult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

(declare-fun ref (ty) ty)

(declare-fun refqtmk (ty uni) uni)

;; ref'mk_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort (ref a) (refqtmk a x)))))

(declare-fun contents (ty uni) uni)

;; contents_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

;; contents'def
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort a u) (= (contents a (refqtmk a u)) u)))))

;; ref_inversion
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort (ref a) u) (= u (refqtmk a (contents a u)))))))

(declare-fun a () Int)

(declare-fun b () Int)

;; H
  (assert (< b 0))

(declare-fun la () Int)

;; Ensures
  (assert (= la (- a)))

(declare-fun lb () Int)

;; Ensures
  (assert (= lb (- b)))

(declare-fun i () Int)

(declare-fun s () Int)

;; LoopInvariant
  (assert (= s (* la i)))

;; H
  (assert (not (< i lb)))

(assert
;; produitqtvc
 ;; File "/home/tbonetto/Annee_1/Modelisation/BE/be_2021_S1_Bonetto_Tom_Xu_Thierry/why3_exercice_4.mlw", line 9, characters 6-13
  (not (= s (* a b))))
(check-sat)
