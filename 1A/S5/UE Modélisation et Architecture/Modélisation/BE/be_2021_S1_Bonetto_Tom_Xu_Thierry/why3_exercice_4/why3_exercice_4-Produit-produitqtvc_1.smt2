;; produced by cvc4_16.drv ;;
(set-logic AUFBVFPDTNIRA)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
(set-option :produce-models true)
(set-option :incremental true)
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun string () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

(declare-fun index_bool (Bool) Int)

(declare-sort tuple0 0)

(declare-fun tuple01 () ty)

(declare-fun Tuple0 () tuple0)

(declare-fun ref (ty) ty)

(declare-fun refqtmk (ty uni) uni)

(declare-fun contents (ty uni) uni)

(declare-fun a () Int)

(declare-fun b () Int)

(declare-fun la () Int)

(declare-fun lb () Int)

(declare-fun i () Int)

(declare-fun s () Int)

(declare-fun s_vc_constant () Int)

(declare-fun a_vc_constant () Int)

(declare-fun b_vc_constant () Int)

(assert
;; produitqtvc
 ;; File "/home/tbonetto/Annee_1/Modelisation/BE/be_2021_S1_Bonetto_Tom_Xu_Thierry/why3_exercice_4.mlw", line 9, characters 6-13
  (not (= s (* a b))))
(check-sat)
(get-model)
;; b_vc_axiom
  (assert (= b_vc_constant b))

;; a_vc_axiom
  (assert (= a_vc_constant a))

;; s_vc_axiom
  (assert (= s_vc_constant s))

;; H
  (assert (not (< i lb)))

;; LoopInvariant
  (assert (= s (* la i)))

;; Ensures
  (assert (= lb (- b)))

;; Ensures
  (assert (= la (- a)))

;; H
  (assert (< b 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

;; index_bool_True
  (assert (= (index_bool true) 0))

(check-sat)
(get-model)
;; ref_inversion
  (assert
  (forall ((a1 ty))
  (forall ((u uni))
  (=> (sort (ref a1) u) (= u (refqtmk a1 (contents a1 u)))))))

;; contents'def
  (assert
  (forall ((a1 ty))
  (forall ((u uni)) (=> (sort a1 u) (= (contents a1 (refqtmk a1 u)) u)))))

;; contents_sort
  (assert (forall ((a1 ty)) (forall ((x uni)) (sort a1 (contents a1 x)))))

;; ref'mk_sort
  (assert
  (forall ((a1 ty)) (forall ((x uni)) (sort (ref a1) (refqtmk a1 x)))))

;; CompatOrderMult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

;; tuple0_inversion
  (assert (forall ((u tuple0)) (= u Tuple0)))

;; bool_inversion
  (assert (forall ((u Bool)) (or (= u true) (= u false))))

;; match_bool_False
  (assert
  (forall ((a1 ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a1 z1) (= (match_bool a1 false z z1) z1)))))

;; match_bool_True
  (assert
  (forall ((a1 ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a1 z) (= (match_bool a1 true z z1) z)))))

;; match_bool_sort
  (assert
  (forall ((a1 ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a1 (match_bool a1 x x1 x2)))))

;; witness_sort
  (assert (forall ((a1 ty)) (sort a1 (witness a1))))

(check-sat)
(get-model)
